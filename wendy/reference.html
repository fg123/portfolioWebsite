<!--
Author: Felix Guo
Copyright Felix Guo 2016
-->
<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
		<title>WendyScript Reference Manual</title>

		<!-- Bootstrap -->
		<link href="bootstrap.css" rel="stylesheet">
		
		<!--Google Font Links-->
		<link href='//fonts.googleapis.com/css?family=Raleway' rel='stylesheet' type='text/css'>
		<link href='//fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
		
		
		<link rel="icon" type="image/png" href="../images/icon.png">

		<link rel="stylesheet" href="main.css" type="text/css">
		
		<link rel="stylesheet" href="wendyHighlighting.css" type="text/css">
	</head>
	<body>
	 	<div class="mainContainer" style="padding-bottom:50px">
			<div class="row title">
				<div class="col-md-12">
					<h1 id="TOP">Wendy<span>Script</span></h1>
					<h2 class="reftitle">Reference Manual</h2>
				</div>
			</div>
			<div class="row">
				<div class="col-md-3" id="toc"></div>
				<div class="col-md-9 content reference"> 
			<h1>Welcome</h1>
				<p>Welcome to the WendyScript reference manual. Credits to the C Reference Manual by Dennis M. Ritchie from which
					I have derived a similar layout for this reference manual. 
					<a href="https://www.student.cs.uwaterloo.ca/~cs136/resources/cman.pdf">C Reference Manual</a>.
				</p>
			<h1>Lexical Conventions</h1>
				<p>There are six kinds of lexical tokens: identifiers, keywords, literals, operators, 
					and seperators. Spaces, tabs, newlines, and comments are ignored, unless to separate
					tokens. Similar to C, if the parser has read up to a given character, the next token
					will include the longest string of characters that can constitute as a token.</p>					
				<h2>Comments</h2>
					<p>WendyScript only supports inline comments, which can be denoted by: <code>//</code>. 
					When encountered, the parser will ignore all following characters until reaching a newline. </p>

				<h2>Identifier</h2>
					<p>An identifier is a sequence of alphabetical characters and numeric characters given that the first
						character must be alphabetical. Underscores are considered alphabetical and identifier
						names are case sensitive. Identifier names can only be 59 characters long. </p>
						<div class="panel panel-warning">
							<div class="panel-heading"><b>But why?</b></div>
							<div class="panel-body">
								Each <i>stack frame</i> is a list of <i>stack entries</i>, and each
								stack entry stores the identifier name and the address at which the corresponding value
								resides. The address requires 4 bytes, and each <i>stack entry</i> is defined to be 64 bytes.
								This gives us 60 bytes to store the identifier name and (including the null terminator), the
								space for 59 characters in an identifier name.
							</div>
						</div>
				<h2>Keywords</h2>
					<p>The following list of identifiers are reserved as keywords and may not be used otherwise.</p>
					<pre><code>and or if else loop 
true false none
Bool String Number List Address typeof 
let set ret explode req time inc dec input struct assert</code></pre>

				<h2>Literals</h2>
					<p>String literals are surrounded by double quotes: <code>"This is a string literal."</code>.</p>
					<p>Number literals can be integer, decimal or negative: <code>1, -1, 0.3, -0.5</code>.</p> 
					<p>List literals are surrounded by square brackets. Since WendyScript is
						dynamically typed, the type of data a list holds need not be predeclared. Lists can be nested.
						The following are all valid lists:
						<pre><code>[1, 2, 3]
["Hello", "world!"]
[1, "hello"]
[true, false, "hello"]
[["hello", 1], ["world", 2]]</code></pre></p>
					<p>The <code>time</code> literal returns the current UTC time as a Number.</p>
					<p>Object Type literals are surrounded by angle brackets: <code>&lt;struct&gt;</code>. This can be used to compare
					types:
					<pre><code>let a = [1, 2, 3];
					a.type == &lt;list&gt;; // true </code></pre>
					</p>

			<h1>Memory and lvalues</h1>
				<p>Wendy's VM's memory is constructed in such a way that a memory block holding a piece of data can be
					a string, a boolean, a number, an address, or a reference to a list. </p>
				<p>A lvalue is simply an expression that refers to a location in memory. One example is
					an identifier, as it points to a place in memory where the data bound to that
					identifier is stored. There are operators that produce lvalues and statements and 
					operators that require lvalues as operands or arguments. These will be specified during
					discussion of the operators and statements.</p>
				
			<h1>Expressions</h1>
				<p>The precedence of expression evaluation is the same as the order of the subsections of this section. Within
					each subsection, the precedence is the same and the sub-expression is evaluated with left to right associativity.
				</p>
				<h2>Primary Expressions</h2>
					<h3>Identifier</h3>
						<p>An identifier is a primary expression as long as it has been declared or defined previously. 
							It's type is specified by the data stored at the memory location it references. An identifier is 
							always an lvalue expression unless the identifier references a List (and not an element of). </p>
						<p>Unlike in C, functions are first class and therefore identifiers that are bound to functions can act
							as lvalue expressions. The identifier will simply evaluate to the address of the function start
							instruction if used in an expression.</p>
					<h3>Literals</h3>
						<p>All literals (Strings, Numbers, Booleans, Lists) are primary expressions. Literals are not lvalues.</p>
					<h3><code>( <i>expression</i> )</code></h3>
						<p>A parenthesized expression is a primary expression whose type and value are identical to the expression 
							within the parentheses. The presence of parentheses do not affect whether or not the expression is an
							lvalue or not.</p>
					<h3><code><i>primary-expression</i> [ <i>expression</i> ]</code></h3>
						<p>Brackets after a primary expression indicate a list-element reference, and therefore, the 
							<i>primary-expression</i> must be a List or a String, and <i>expression</i> must be a Number or a Range. If the expression is a
							Range, a subarray or substring where the Range refer to the indices of the original array will be returned.</p>
					<h3><code><i>primary-expression</i> ( <i>optional-expression-list</i> )</code></h3>
						<p>A primary expression followed by a set of parentheses indicate a function call. The optional
							expression list contains expressions separated by commas. WendyScript functions
							are always pass by value, that is, each expression in the optional expression list is evaluated
							to a value that is then passed into the function. The return value is passed back to the 
							primary expression. Recursive functions are always permitted. The <i>primary-expression</i> must be
							a valid address to a function.</p>
					<h3><code><i>expression</i>.<i>member</i></code></h3>
						<p>Member access operator. If the expression is a Struct, <i>member</i> must be a static member of the Struct. If the expression
						is an instance of a Struct, <i>member</i> can be either static or instance member. There are two members that 
						apply to all expressions. <i>size</i> and <i>type</i> will return the size and type of the expression before it.</p>
				<h2>Unary Operators</h2>
					<h3><code>& <i>lvalue-expression</i></code></h3>
						<p>The result of this operator is a pointer to the object referred to by the lvalue-expression. 
							Note: this has higher precedence than the list-element reference.</p>
					<h3><code>* <i>expression</i></code></h3>
						<p>The result of this operator is the object that resides at the address given by the expression.
							In this sense, the expression must be an Address.</p>
					<h3><code>- <i>expression</i></code></h3>
						<p>The result of this operator is the negation of the given expression. The expression must be Number.</p>
					<h3><code>! <i>expression</i></code></h3>
						<p>The result of this operator is false if the given expression is true, and true if the given expression
							is false. The expression must be a Boolean. </p>
				<h2>Multiplicative Operators</h2>
					<h3><code><i>expression</i> * <i>expression</i></code></h3>
						<p>Multiplies the two expressions. Both expressions must be Numbers or Addresses. The result
							is always a Number.</p>
					<h3><code><i>expression</i> / <i>expression</i></code></h3>
						<p>Divides the two expressions. Both expressions must be Numbers or Addresses. The second
							expression cannot be 0 and the result is always a Number.</p>
					<h3><code><i>expression</i> \ <i>expression</i></code></h3>
						<p>Integer divides the two expressions. Both expressions must be Numbers or Addresses. The second
							expression cannot be 0 and the result is always a Number.</p>
					<h3><code><i>expression</i> % <i>expression</i></code></h3>
						<p>Produces the remainder from the division of the first and the second expression.
							Both expressions must be Numbers or Addresses. The second
							expression cannot be 0 and the result is always a Number. The produced Number will
							have the same sign as the dividend.</p>
				<h2>Additive Operators</h2>
					<h3><code><i>expression</i> + <i>expression</i></code></h3>
						<p>Addition operator, Addresses are converted to Numbers: 
							<ul>
								<li>Number + Number: mathematical addition</li>
								<li>String + Number: Number is converted to a String and then concatenated</li>
								<li>Number + String: same as above</li>
								<li>String + String: string concatenation</li>
								<li>List + List: list concactenation, produces a new List</li>
								<li><i>expression</i> + List: appends the value of expression to the front of the List</li>
								<li>List + <i>expression</i>: appends the value of expression to the end of the List</li>
							</ul>
						</p>
					<h3><code><i>expression</i> - <i>expression</i></code></h3>
						<p>Subtracts the two expressions. Expressions must be numbers or addresses.
						</p>
				<h2>Special Operators</h2>
					<h3><code><i>expression</i>..<i>expression</i></code></h3>
						<p>This creates a Range object from two numbers inclusive. Both expressions
							must be Numbers. If the range object is used as an element in a list during instantiation,
							it will be expanded to become a list of numbers. For example: </p>
						<pre><code>let a = [1..3, 5..8];
a;</code></pre>
<pre><code>[1, 2, 3, 5, 6, 7, 8]</code></pre>
				<h2>Equality Operators</h2>
				 	<p>All Addresses are converted to Numbers:</p>
					<h3><code><i>expression</i> == <i>expression</i></code></h3>
						<p>Returns true if both expressions are of the same type and value, and false otherwise.</p>
					<h3><code><i>expression</i> != <i>expression</i></code></h3>
						<p>Returns false if both expressions are of the same type and value, and true otherwise.</p>
					<h3><code><i>expression</i> ~ <i>expression</i></code></h3>
						<p>Returns true if the first expression exists within the second expression. The second expression
							must be a List.
						</p>
					<h3><code><i>expression</i> > <i>expression</i></code></h3>
						<p>Returns true if the first expression is greater than the second expression. Both expressions must be Numbers.</p>
					<h3><code><i>expression</i> < <i>expression</i></code></h3>
						<p>Returns true if the first expression is less than the second expression. Both expressions must be Numbers.</p>
					<h3><code><i>expression</i> >= <i>expression</i></code></h3>
						<p>Returns true if the first expression is greater than or equal to the second expression. Both expressions must be Numbers.</p>
					<h3><code><i>expression</i> <= <i>expression</i></code></h3>
						<p>Returns true if the first expression is less than or equal to the second expression. Both expressions must be Numbers.</p>
			<h1>Statements</h1>
				<p>Statements are always executed in sequence.</i>
				<h2>Expression Statements</h2>
					<h3><code>expression ;</code></h3>
						<p>This is an expression statement. These are mostly used in assignment, mutation, or function calls. Expression statements will be printed to the screen by default, with a new-line appended.</p>
					<h3><code>@ expression ;</code></h3>
						<p>Follows the exact same rules as the one before, except the expression will be printed without a new-line appended.</p>
				<h2>Group of Statements</h2>
					<h3><code>{ <i>statement-list</i> }</code></h3>
					<p>Groups of statements can be grouped using curling braces. A statement list 
						is simply a list of statements delimited by semicolons.</p>
				<h2>Functions</h2>
					<h3><code>(<i>optional-arg-list</i>) { <i>statement-list</i> }</code></h3>
						<p>This is a function block, and can be used to represent a function. However, this is not considered an expression.</p>
					<h3><code>#: (<i>optional-arg-list</i>) { <i>statement-list</i> }</code></h3>
						<p>This is a lambda function, and <i>is</i> considered an expression.</p>
					<p>Functions are considered first-class in WendyScript. Binding a function to an identifier will store the
						function's address to the identifier. When a function returns, all values in the call stack are persisted in 
						memory, and therefore, addresses to objects created within a function can be used outside and still
						be valid.</p>
				<h2>Declarations</h2>
					<p>A value can be bound to an identifier with the <i>let</i> statement.</p>
					<h3><code>let <i>identifier</i>;</code></h3>
						<p>Declares an identifier and binds the value <code>none</code> to it.</p>
					<h3><code>let <i>identifier</i> = <i>expression</i>;</code></h3>
						<p>Declares an identifier and binds the given <i>expression</i> to it.</p>
					<h3><code>let <i>identifier</i> => <i>function-block</i>;</code></h3>
						<p>Declares an identifier and sets it to an address pointing to the given function.</p>
					<h3><code>let <i>identifier</i> [ <i>expression</i> ] ;</code></h3>
						<p>Declares an identifier and sets it to a List. The size is determined by the <i>expression</i>, which must be
						a Number. All of the List's elements are set to <code>none</code>.</p>
					<h3><code>let <i>identifier</i> [ <i>expression</i> ] = <i>expression</i> ;</code></h3>
						<p>Same process as the one above, but all of the List's elements are set to the given <i>expression</i>.</p>
				<h2>Mutation and Input</h2>
					<h3><code>set <i>lvalue-expression</i> = <i>expression</i>;</code></h3>
					<p>Sets the value pointed at by the given <i>lvalue-expression</i> to the given <i>expression</i>.</p>
					<h3><code>inc <i>lvalue-expression</i>;</code></h3>
						<p>Increments the value pointed at by the given
							<i>lvalue-expression</i> by 1. The <i>lvalue-expression</i> must point to a Number.</p>
					<h3><code>dec <i>lvalue-expression</i>;</code></h3>
						<p>Decrements the value pointed at by the given
							<i>lvalue-expression</i> by 1. The <i>lvalue-expression</i> must point to a Number.</p>
					<h3><code>input <i>lvalue-expression</i>;</code></h3>
						<p>Prompts the user for input, which is then stored in the memory location
							pointed to by the given <i>lvalue-expression</i>. If the user inputs a valid
							Number (that is, an integer with an optional decimal part), the inputted value will be stored as such. 
							Any other input will be stored as a string.</p>
					<h3><code>explode <i>lvalue-expression</i>;</code></h3>
						<p>Given an <i>lvalue-expression</i> that points to a String, a List of the String's characters
						is created, and the given <i>lvalue-expression</i> is mutated to be that List.</p>
					
				<h2>Conditions</h2>
					<p>A <i>conditional-statement</i> follows the form:
					<h3 class="inline"><code>if ( <i>expression</i> ) { <i>statement-list</i> };</code></h3>
<h3 class="inline"><code>if ( <i>expression</i> ) { <i>statement-list</i> } else <i>conditional-statement</i>;</code></h3>
					<p>The given expression must be a Boolean. If the expression evaluates to <code>true</code>,
					the first <i>statement-list</i> is executed. If the expression evaluates to <code>false</code>, then the 
					<i>conditional-statement</i>, if any, will be executed.
				<h2>Loop</h2>
					<p>A <i>loop-statement</i> follows the form:</p>
					<h3 class="inline"><code>loop ( <i>expression</i> ) { <i>statement-list</i> };</code></h3>
					<p>The given expression must be a Boolean. The given <i>statement-list</i> is executed
					repeatedly as long as the given expression evaluates to <code>true</code>. The test takes place
					before the execution of the <i>statement-list</i>.</p>
				<h2>Function Return</h2>
					<p>A value can be passed from a function to the caller using the <i>ret</i> statement.</p>
					<h3 class="inline"><code>ret <i>optional-expression</i>;</code></h3>
					<p>A function that exits without <code>ret</code> will pass <code>none</code> back to the caller. If this
					happened to be a top-level expression, <code>&lt;none&gt;</code> will be printed to the screen. This
					behaviour can be avoided by calling <code>ret;</code> which will not print anything to the screen 
					upon the exit of the function.</p>
				<h2>Assertions</h2>
					<p>A requirement of a function can be asserted with the <i>assert</i> statement.</p>
					<h3 class="inline"><code>assert <i>expression</i>;</code></h3>
					<p>The assertion will only pass if the given expression evaluates to <i>true</i> and will fail if it is any other value.</p>
				<h2>Structures</h2>
					<p>Objected Oriented Programming can be achieved through the use of structures.</p>
					<h3 class="inline"><code>struct <i>struct-name</i><i>:optional-parent</i> => <i>( instance-member-list ) [ static-member-list ]</i>;</code></h3>
					<p>One or both of the member lists can be omitted or placed in any order. By default the constructor will be the function 
						<code><i>struct-name</i> ( <i>instance-member-list</i> )</code>, which creates a new instance of the structure.
						You can overwrite the constructor function by setting <code><i>struct-name</i>.<i>init</i></code> but the overwritten
						init function must end with <code>ret this;</code> to pass the instance back.</p>
				<h2>Additional Modules</h2>
					<p>Standard WendyScript implementations should include a set of module files that aid with basic
						tasks. </p>
					<h3 class="inline"><code>req "<i>filename</i>";</code></h3>
					<p>This command will simply replace the statement with the contents of <i>filename</i>. Note that
					the <i>filename</i> is relative to the location of the Wendy Libraries, which are usually
					installed and copied into the wendy-lib directory located in the installation directory.</p>
				</div>
			</div>
			
		</div>
		<div class="fewter">
				&copy; Copyright Felix Guo 2017
		</div>		
		<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
		<!-- Include all compiled plugins (below), or include individual files as needed -->
		<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>		
		<script src="wendyHighlighting.js" type="text/javascript"></script>
		<script src="reference.js" type="text/javascript"></script>
	</body>
</html>
