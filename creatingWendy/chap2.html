<!--
Author: Felix Guo
Copyright Felix Guo 2017
-->
<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
		<title>Chapter 2: Language Data and Syntax | Creating WendyScript</title>

		<!-- Bootstrap -->
		<link href="css/bootstrap.css" rel="stylesheet">
		
		<!--Google Font Links-->
		<link href='//fonts.googleapis.com/css?family=Raleway' rel='stylesheet' type='text/css'>
		<link href='//fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
		<link rel="icon" type="image/png" href="../images/icon.png">
		<link rel="stylesheet" href="css/main.css" type="text/css">
		<!--<link href="css/monokai.css" rel="stylesheet" type="text/css">-->
		<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/monokai-sublime.min.css">
		<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js"></script>

		<link href="../wendy/wendyHighlighting.css" rel="stylesheet" type="text/css">
	</head>
	<body>
	 	<div class="mainContainer">
			<div class="row title">
				<div class="col-md-12">
					<h1>Creating<span>WendyScript</span></h1>
					<h2>Chapter 2: Language Data and Syntax</h2>
				</div>
			</div>
			<div class="row">
				<div class="col-md-9 col-md-push-3 content">
					<!-- content -->
					<h1 id="data">Data</h1><p>	The first thing we want to do is determine how data is represented	in our language. I created WendyScript with a few data types. We have	numbers (doubles or integers), strings, booleans, and a "none" type, or	more commonly known as NULL. Out of these types, we need to store two 	kinds of data, numbers and strings. I wanted WendyScript to be dynamically typed,	so I used a union to support this kind of data storage. Although it can 	also be done by storing every value as a string, it's easier and faster	to perform numerical operations without converting from a string to a	double, then back again every time.</p><p>	We'll set up this kind of data structure with a union. I'll allow a max	string length of 1024 for now. This can be further expanded to dynamic	storage or a bigger static number. For now, this goes in our <code>token.h</code>	file.</p><pre><code class="cpp">#define MAX_STRING_LEN 1024typedef union {	double number;	char string[MAX_STRING_LEN];} data;</code></pre>			<h1 id="syntax">Syntax</h1><p>	The next thing we want to establish is the syntax of the language we want 	to create. What key features will our language have? For WendyScript, I	wanted to implement basic variables, conditional structures, loops,	and first class functions. I wanted WendyScript to have a similar syntax 	to C, so semicolons will mark the end of each WendyScript block of command.</p><pre><code class="nohighlight">let my_variable = 10;set my_variable = "string";let x => (arg1, arg2) { function body; };x(my_variable, 10);if (condition) { code; } else { code; };loop (condition) { code; };</code></pre><p>	As you can see, every line, even control flow, ends in a semicolon. The full	syntax and all the commands for WendyScript can be found at 	<a href="../wendy/">WendyScript Documentation</a>. I would recommend coming up	with a pretty comprehensive way you want your language to look before moving 	on to the next step. </p><h1 id="tokens">Tokens</h1><p>	As stated before, the next step is converting a string of code into a list of	tokens. From our syntax, we'll want to create a list of tokens that can	break our code into readable chunks. Since we are using semicolons to seperate 	lines of code, we do not need to depend on whitespace. We can create an <code>enum</code> 	in <code>token.h</code>:</p><pre><code class="cpp">typedef enum { 	// Single-character Tokens	LEFT_PAREN, RIGHT_PAREN, LEFT_BRACE, RIGHT_BRACE, LEFT_BRACK, RIGHT_BRACK,	COMMA, DOT, MINUS, PLUS, SEMICOLON, SLASH, STAR, COLON, AT, HASH, PERCENT,	INTSLASH, AMPERSAND,	// Comparison Tokens	NOT, NOT_EQUAL,	EQUAL, EQUAL_EQUAL, 	GREATER, GREATER_EQUAL,	LESS, LESS_EQUAL,	// Literals.	IDENTIFIER, STRING, NUMBER,	// Conditionals	AND, OR, IF, ELSE, ELSEIF, TRUE, FALSE,	// Definitons	LET, SET, LOOP, DEFFN,		// Special Commands	RET, INPUT, INC, DEC, STRUCT, MEMSET, PRINTSTACK,	// Special Forms	NONE, NONERET} token_type;</code></pre><p>	To clarify some of the tokens, <code>INTSLASH</code> is a backslash, which	in WendyScript represents integer division, <code>DEFFN</code> is <code>=></code>, 	which is used to bind a function to an identifier. The special commands are 	simply built in functions in WendyScript. There's a distinction between	<code>NONE</code> and <code>NONERET</code>. <code>NONERET</code> is used to	signify a function with a void return. This will come into play when we see	how top level expressions are always printed onto the screen in WendyScript.	For example, if we had a function that returned void, we don't want <code>&lt;none&gt;</code>	to be printed on the screen.</p><p>	Once we have determined all the types of tokens that are available in our 	language, we can con<b>struct</b> a token structure in our <code>token.h</code></p><pre><code class="cpp">typedef struct {	token_type t_type;	int t_line;	data t_data;} token;</code></pre><div class="well"><b>Note:</b> This is a strange incident that I ran into whilecreating WendyScript. Since we're going to be storing a bunch of these tokens,we want to minimize the size of the struct. In theory, the sizes (int, data, and int) are (4, 1024, and 4 respectively) all powers of 4, so there should be no compiler padding.However, when I first created this struct, I sandwiched the t_data between t_type and t_line, which gave me a sizeof(token) of 1040 (an extra 8 padded bytes). Moving t_datato after t_line gave me 1032 bytes (0 padded bytes).<img src="img/chap2/structsize.png" class="img-thumbnail zoom"></div><p>	<code>t_line</code> stores the line number of the token read, so we can	alert the user where errors occur when they do. We can also create a set 	of functions to create tokens:</p><pre><code class="cpp">// make_token(t, d) returns a new tokentoken make_token(token_type t, data d);// make_data_int(i) makes a data union with the integer provideddata make_data_num(double i);// makeDataStr(s) makes a data union with the string provideddata make_data_str(char* s);// none_token() returns a none tokentoken none_token();// false_token() returns a false tokentoken false_token();// true_token() returns a true tokentoken true_token();// print_token(t) prints the value of the token to the stringvoid print_token(const token* t);// print_token_inline(T) prints the value of the token inlinevoid print_token_inline(const token* t);</code></pre><p>	The corresponding implementation goes in <code>token.c</code>:</p><pre><code class="cpp">token none_token() {	return make_token(NONE, make_data_str("&lt;none&gt;"));}token true_token() {	return make_token(TRUE, make_data_str("&lt;true&gt;"));}token false_token() {	return make_token(FALSE, make_data_str("&lt;false&gt;"));}token make_token(token_type t, data d) {	token token_ = { t, 0, d };	return token_;}data make_data_num(double i) {	data d;	d.number = i;	return d;}data make_data_str(char* s) {	data d;	strcpy(d.string, s);	return d;}void print_token(const token* t) {	if (t->t_type == NUMBER) {		printf("%g\n", t->t_data.number);	}	else {		printf("%s\n", t->t_data.string);	}}void print_token_inline(const token* t) {	if (t->t_type == NUMBER) {		printf("%g", t->t_data.number);		fflush(stdout);	}	else {		printf("%s", t->t_data.string);		fflush(stdout);	}}</code></pre><p>	A couple of key points here. The format in <code>none_token()</code>, <code>true_token()</code>,	and <code>false_token()</code> determines how those data types are displayed to the user.	We also use the format string <code>%g</code> when printing a number to ensure	trailing zeros are truncated. Since numbers are stored as double in our data, if the user 	stores an integer and tries to display it, we don't want it to show as <code>2.000000</code>	but rather just as <code>2</code>. We also want to use use <code>fflush</code> in <code>print_token_inline()</code>	because if we do not print a newline within a printf statement, the contents will simply 	be stored in the buffer and not flushed. This leads to some strange debugging cases, so just	to be safe, we flush the buffer to ensure the contents are displayed on the screen.</p><p>	For more information about this behaviour: 	<a href="http://stackoverflow.com/questions/1716296/">StackOverflow</a>.</p><p>	Let's revisit our previous example and see how a string like 	<code>let my_variable = 10;</code> will be represented in a list of tokens.</p><img src="img/chap2/tokens.png" class="img-thumbnail"><p>	We have tokens defined, so in the next chapter, we can start to build the 	main program and the scanner, which converts a string of code into a list	of tokens.</p>
				</div>

				<div class="col-md-3 col-md-pull-9 navigation">
					<div class="list-group mainmenu">
					</div>
				</div>
			</div>
		</div>
		<div class="fewter">
				&copy; Copyright Felix Guo 2017
		</div>		
		<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
		<!-- Include all compiled plugins (below), or include individual files as needed -->
		<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>		
		<script src="js/spy.js" type="text/javascript"></script>
		<script src="js/pageScroll.js" type="text/javascript"></script>
		<script src="../wendy/wendyHighlighting.js" type="text/javascript"></script>
		<script>
		$(document).ready(function() {
			$('pre code.cpp').each(function(i, block) {
				hljs.highlightBlock(block);
			});
		});
		</script>
		<!--<script src="js/rainbow-custom.min.js" type="text/javascript"></script>-->
	</body>
</html>
