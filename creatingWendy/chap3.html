<!--
Author: Felix Guo
Copyright Felix Guo 2017
-->
<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
		<title>Chapter 3: REPL and Scanner | Creating WendyScript</title>

		<!-- Bootstrap -->
		<link href="css/bootstrap.css" rel="stylesheet">
		
		<!--Google Font Links-->
		<link href='//fonts.googleapis.com/css?family=Raleway' rel='stylesheet' type='text/css'>
		<link href='//fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
		<link rel="icon" type="image/png" href="../images/icon.png">
		<link rel="stylesheet" href="css/main.css" type="text/css">
		<!--<link href="css/monokai.css" rel="stylesheet" type="text/css">-->
		<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/monokai-sublime.min.css">
		<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js"></script>

		<link href="../wendy/wendyHighlighting.css" rel="stylesheet" type="text/css">
	</head>
	<body>
	 	<div class="mainContainer">
			<div class="row title">
				<div class="col-md-12">
					<h1>Creating<span>WendyScript</span></h1>
					<h2>Chapter 3: REPL and Scanner</h2>
				</div>
			</div>
			<div class="row">
				<div class="col-md-9 col-md-push-3 content">
					<!-- content -->
					<h1 id="REPL">REPL</h1><p>	The first step in building our main program is to construct a basic REPL	mode for our interpreter. REPL stands for <b>R</b>ead, <b>E</b>xecute,	<b>P</b>rint, <b>L</b>oop, and that's exactly what it does. Instead of 	giving your interpreter a file to process, we allow it to listen for input	and process it line by line instead. This allows us to test out our	functions for scanning and evaluation of the code quickly and easily. </p><p>	Our main program looks like this:</p><pre><code class="cpp">// WendyScript Interpreter in C// By: Felix Guo// // main.c: used to handle REPL and calling the interpreter on a file.const char* WENDY_VERSION = "Wendy 1.1";const unsigned int INPUT_BUFFER_SIZE = 2048;int main(int argc, char** argv) {	if (argc > 2) {		printf("Usage: wendy or wendy [file]\n");		return 1;	}	else if (argc == 1) {		printf("Welcome to %s\nCreated by: Felix Guo\n", WENDY_VERSION);		char *input_buffer;		// ENTER REPL MODE		while (1) {			input_buffer = readline("> ");			if(!input_buffer) return 0;			run(input_buffer);			free(input_buffer);		}	}	else {		// FILE READ MODE	}}</code></pre><p>	Here, I've used the GNU library <code>readline()</code>, which returns a 	pointer to dynamically allocated memory, so I have to free it. If	<code>readline()</code> is not available, you could use <code>getline()</code> 	and parse the resulting string yourself, but this is much more tedious. The	run function exists inside <code>interpreter.h</code>, which is the module	that houses the main code for the interpreting process. Let's take a look at	what that function looks like. We also set a location to store the resulting 	token list after scanning.</p><pre><code class="cpp">static token* tokens;static size_t tokens_count;void run(char* input_string) {	tokens_count = scan_tokens(input_string, &tokens);	bool b;	eval_fn(0, 0, 0, 0, &b);	free(tokens);}</code></pre><p>	The code and arguments for <code>eval_fn()</code> will be explained in more	detail in the next chapter. If you want to test out the scanner for now, you	can just comment it out. The <code>scan_tokens()</code> will take the 	given input_string and build a list of tokens (which will be malloc'ed) and	the pointer will be passed to the given argument. It will also return an	integer representing how many tokens were created. </p><h1 id="scanner">Scanner</h1><div class="well">The majority of the code here is designed and implemented byRobert Nystrom over at <a href="http://craftinginterpreters.com">Crafting Interpreters</a>. I have simply ported the code over from Java to C.</div><p>	To start off our scanner module, we need some module-global variables in	<code>scanner.c</code></p><pre><code class="cpp">static size_t source_len; // length of the source stringstatic size_t current; // keep track of which character we're looking atstatic size_t start; // keep track of the start of the token we're looking forstatic char* source; // source stringstatic token* tokens; // token list static size_t tokens_alloc_size; // size of token stringstatic size_t t_curr; // size of token liststatic size_t line; // current line of source string</code></pre><p>	For now, <code>token_alloc_size</code> doesn't really matter, but will come	into play later when we want to implement structs. I built my <code>scan_tokens()</code>	function as below:</p><pre><code class="cpp">int scan_tokens(char* source_, token** destination) {	source = source_;		// allocate enough space for the max length of the source, probably not	//   needed but it's a good setup.	source_len = strlen(source);	tokens_alloc_size = source_len;	tokens = (token*)malloc(tokens_alloc_size * sizeof(token));	t_curr = 0;	current = 0; 	line = 1;	while (!is_at_end()) {		start = current;		scan_token();	}	*destination = tokens;	return t_curr;}</code></pre><p>	We note that the maximum number of tokens we would need to store is equivalent	to the maximum length of the source file, since every token is at least one	character. We'll allocate enough space for this, reset the counters, and go 	through the string, scanning for tokens. We then pass the pointer to 	the allocated memory back out, and return the number of tokens we read. </p><p>	When we want to convert a series of characters to a token, we first set the 	<code>start</code> variable to the position of the beginning of the token,	scan until we find a match, then save those characters into the data field of	our token. We'll start by writing two functions in <code>interpreter.c</code> 	to add tokens to the list. Notice we use <code>current - start</code> to 	retreive the relevant characters. Also notice that since we're building a	new string from a pre-existing source, we must append the null terminator.</p><p>	In our <code>add_token_V()</code> function, we also do some preprocessing for the ELSEIF token.	If we encounter an IF token, and the previously added one was an ELSE, then we	simply make that an ELSEIF token. This eliminates the need for our interpreter	to do that extra step when interpreting the code. After incrementing the counter,	if we exceed the <code>tokens_alloc_size</code>, we reallocate extra bytes.</p><pre><code class="cpp">void add_token(token_type type) {	char val[current - start + 1];	memcpy(val, &source[start], current - start);	val[current - start] = '\0';	add_token_V(type, make_data_str(val));}void add_token_V(token_type type, data val) {	if (t_curr != 0 && tokens[t_curr - 1].t_type == ELSE			&& type == IF) {		// Processing for ELSEIF		token new_t = { ELSEIF, make_data_str("else if"), line };		tokens[t_curr - 1] = new_t;	}	else {		token new_t = { type, val, line };		tokens[t_curr++] = new_t;	}	if (t_curr == tokens_alloc_size) {		// Reallocate if we exceed!		tokens_alloc_size += 200;		token* tmp = (token*)realloc(tokens, tokens_alloc_size * sizeof(token));		if (tmp) {			tokens = tmp;		}		else {			printf("Memory error occured during realloc.\n");			exit(1);		}	}}</code></pre><p>	Once we have these functions in place, we can start writing our functions. 	We can start with our <code>is_at_end()</code> function.</p><pre><code class="cpp">// is_at_end() returns true if scanning index reached the endbool is_at_end() {	return current >= source_len;}</code></pre><p>	Before start building our <code>scan_token()</code> function, which	matches the next token, we need some helper functions to analyze the characters. We'll	write an <code>advance()</code> function first, which moves the index to the next character. </p><pre><code class="cpp">// advance() returns the current character then moves onto the next onechar advance() {	current++;	return source[current - 1];}// scan_token() processes the next token void scan_token() {	char c = advance();		switch(c) {		case '(': add_token(LEFT_PAREN); break;		case ')': add_token(RIGHT_PAREN); break;		case '[': add_token(LEFT_BRACK); break;		case ']': add_token(RIGHT_BRACK); break;		case '{': add_token(LEFT_BRACE); break;		case '}': add_token(RIGHT_BRACE); break;		case '&': add_token(AMPERSAND); break;		case ',': add_token(COMMA); break;		case '.': add_token(DOT); break;		case '-': add_token(MINUS); break;		case '+': add_token(PLUS); break;		case '\\': add_token(INTSLASH); break;		case '%': add_token(PERCENT); break;		case '@': add_token(AT); break;		case ';': add_token(SEMICOLON); break;		case ':': add_token(COLON); break;		case '#': add_token(HASH); break;		case '*': add_token(STAR); break;		...</code></pre><p>	This works great for single-character tokens. What happens when we have to 	match a multi-character token? For example, if we encounter an equal sign (=),	we need to check the next character too! It could be an EQUAL (=), EQUAL_EQUAL (==),	or DEFFN (=>). Let's write another helper function called <code>match(char)</code>	that compares the next token to the given character, returns true and increments	the index if it matches, and returns false otherwise.</p><pre><code class="cpp">// match(expected) checks the next character and advances the indexbool match(char expected) {	if (is_at_end()) return false;	if (source[current] != expected) return false;	current++;	return true;}</code></pre><p>	This allows us to add double character tokens to our <code>scan_token()</code> function.</p><pre><code class="cpp">		case '!': add_token(match('=') ? NOT_EQUAL : NOT); break;		case '=': 			if (match('=')) {				add_token(EQUAL_EQUAL);			}			else if (match('>')) {				add_token(DEFFN);			}			else {				add_token(EQUAL);			}			break;		case '<': add_token(match('=') ? LESS_EQUAL : LESS); break;		case '>': add_token(match('=') ? GREATER_EQUAL : GREATER); break;</code></pre><p>	Next, we want to handle comments, if we encounter two forward slashes, "//",	we want to read until the end of the line and discard all of those characters.	For this, we need a <code>peek()</code> helper function, which returns the next	character without advancing the index (since current represents the current unconsumed	character).</p><pre><code class="cpp">// peek() returns the next character or \0 if we are at the endchar peek() {	if (is_at_end()) return '\0';	return source[current];}</code></pre><p>	With this peek function, we can implement comment searching. We can also add in	white-space characters, and ignore them. If we hit a newline character, we'll	increment the line counter.</p><pre><code class="cpp">		case '/':			if (match('/')) {				// A comment goes until the end of the line.				while (peek() != '\n' && !is_at_end()) advance();			}			else {				add_token(SLASH);			}			break;		case ' ':		case '\r':		case '\t':			// Ignore whitespace.			break;		case '\n':			line++;			break;</code></pre><p>	We've handled all of the single character and double character tokens. We now	need to handle strings, numbers, and identifiers. Identifiers will also need	to be distinguished from special keywords/commands in WendyScript. We'll need 	a few more simple helper functions.</p><pre><code class="cpp">// is_alpha(c) returns true if c is alphabetbool is_alpha(char c) {	return (c >= 'a' && c <= 'z') ||		(c >= 'A' && c <= 'Z') ||		c == '_';}// is_digit(c) returns true if c is digitbool is_digit(char c) {	return c >= '0' && c <= '9';}// is_alpha_numeric(c) returns true if c is alpha AND numericbool is_alpha_numeric(char c) {	return is_alpha(c) || is_digit(c);}</code></pre><p>	During our scanning, if we hit a double quote ("), we'll need to scan until	the next double quote and create a string out of the contents. Let's place this	string processing into a helper function. Here, we peek until we find the 	other double quote (adding newlines as we go), and then pulling the relevant	characters into the token data.</p><pre><code class="cpp">				...				case '"': handle_string(); break;				...</code></pre><pre><code class="cpp">// handle_string() processes the next stringvoid handle_string() {	while (peek() != '"' && !is_at_end()) {		if (peek() == '\n') line++;		advance();	}	// Unterminated string.	if (is_at_end()) {		error(line, UNTERMINATED_STRING);		return;	}	// The closing double quote	advance();	// Trim the surrounding quotes.	int s_length = current - 2 - start;	char value[s_length + 1]; // + 1 for null terminator		memcpy(value, &source[start + 1], s_length);	value[s_length] = '\0';	add_token_V(STRING, make_data_str(value));	}</code></pre><p>	Notice that we've used an <code>error()</code> function, which we will use	to display errors to the user. Our <code>error.h</code> contains a list of 	errors:</p><pre><code class="cpp">// Scanner Messages:#define UNTERMINATED_STRING "Unterminated string!"#define UNEXPECTED_CHARACTER "Unexpected character!"// Running Messages:#define RESERVED_TOKEN "Reserved Token used for Identifier!"#define TOKEN_DECLARED "Identifier was already declared! Use 'set' to mutate!"#define FUNCTION_NO_START "Function start { not found."#define RIGHT_BRACE_NO_CONSISTENT "Mismatch curly brackets }"#define EXPECTED_END_OF_LINE "Expected end of line!"#define COND_EVAL_NOT_BOOL "Condition must evaluate to true or false."#define ID_NOT_FOUND "Identifier not found. Did you declare it?"#define FUNCTION_CALL_MEM_ERROR "Function call pointer is memory out of range."#define FUNCTION_ARG_MISMATCH "Function call has mismatching parameters!"#define PAREN_MISMATCH "Mismatched Parentheses!"#define NOT_NO_VAL "Expected value after ! operator."#define NOT_REQ_BOOL "Expected Boolean value after ! operator."#define SYNTAX_ERROR "Syntax Error!"#define TYPE_ERROR "Type Error!"#define MATH_DISASTER "Division by 0!"#define EXPR_MULT_VALUE "Expression did not evaluate to single value."#define MUTATE_CONST "Identifier is a constant and cannot be modified."#define ARRAY_REF_NOT_NUM "Array index must be number!"#define MEMORY_REF_ERROR "Reference to Memory Out of Range!"#define REQ_FILE_READ_ERR "req: File read error."#define MEMSET_NOT_NUM "Memset requires an integer address!"#define INPUT_ERROR "Input scanning error!"#define UNKNOWN_TOKEN "Unknown Token!"// error(line, message) prints an error message to the screenvoid error(int line, char* message);</code></pre><p>	And the corresponding <code>error.c</code></p><pre><code class="cpp">// error handling functionsvoid error(int line, char* message) {	printf("Runtime Error at line %d: %s\n", line, message);}</code></pre><p>	Now that we have scanned for strings, which are explicitly wrapped (in double quotes), we	can move on to numbers and identifiers. Unlike strings, these are not explicitly wrapped, so first,	we add these to the "default" section of our switch.</p><pre><code class="cpp">		default:			if (is_digit(c)) {				handle_number();			}			else if (is_alpha(c)) {				identifier();			}			else {				printf("Char is %d, %c\n", c, c);				error(line, UNEXPECTED_CHARACTER);			}			break;		// END SWITCH HERE	}}</code></pre><p>	This finishes off our <code>scan_token()</code> function. We just need to 	write the helpers <code>handle_number()</code> and <code>identifier()</code>.	For <code>handle_number()</code> we want to advance as long as the next character	is a digit, or we hit a decimal point, at which point we can look for the decimal part. 	To look two characters ahead, we also need a <code>peek_next()</code> helper	function. Then, the same process as a string is used, except we use <code>strtod()</code>	to convert the string (optionally with a decimal) to a double.</p><pre><code class="cpp">// peek_next() peeks at the character after the next or \0 if at endchar peek_next() {	if(current + 1 >= source_len) return '\0';	return source[current + 1];}// handle_number() processes the next numbervoid handle_number() {	while (is_digit(peek())) advance();	// Look for a fractional part.	if (peek() == '.' && is_digit(peek_next())) {		// Consume the "."		advance();		while (is_digit(peek())) advance();	}		char num_s[current - start + 1];	memcpy(num_s, &source[start], current-start);	num_s[current - start] = '\0';	double num = strtod(num_s, NULL); 	add_token_V(NUMBER, make_data_num(num));}</code></pre><p>	The next step is our <code>identifier()</code> function. We advance until	we find a non-alphanumeric character, and then process the resulting string.</p><pre><code class="cpp">// identifier() processes the next identifier and also handles WendyScript //   keywordsvoid identifier() {	while (is_alpha_numeric(peek())) advance();		char text[current - start + 1];	memcpy(text, &source[start], current - start);	text[current - start] = '\0';	if (strcmp(text, "and") == 0)	{ add_token(AND); }	else if (strcmp(text, "else") == 0)	{ add_token(ELSE); }	else if (strcmp(text, "false") == 0)	{ add_token(FALSE); }	else if (strcmp(text, "if") == 0)	{ add_token(IF); }	else if (strcmp(text, "or") == 0)	{ add_token(OR); }	else if (strcmp(text, "true") == 0)	{ add_token(TRUE); }	else if (strcmp(text, "printstack") == 0)	{ add_token(PRINTSTACK); }	else if (strcmp(text, "let") == 0)	{ add_token(LET); }	else if (strcmp(text, "set") == 0)	{ add_token(SET); }	else if (strcmp(text, "memset") == 0){ add_token(MEMSET); }	else if (strcmp(text, "loop") == 0)	{ add_token(LOOP); }	else if (strcmp(text, "none") == 0)	{ add_token(NONE); }	else if (strcmp(text, "ret") == 0)	{ add_token(RET); }	else if (strcmp(text, "inc") == 0)	{ add_token(INC); }	else if (strcmp(text, "dec") == 0)	{ add_token(DEC); }	else if (strcmp(text, "input") == 0){ add_token(INPUT); }	else if (strcmp(text, "struct") == 0){ 		// HANDLE STRUCT		handle_struct(); 	}	else { add_token(IDENTIFIER); }}</code></pre><p>	Here, <code>handle_struct()</code> is a special form in WendyScript that won't	be covered here. Essentially, it's a shorthand form to generate a predefined	set of functions/code that create constructor and accessor functions in WendyScript.	This is why we had a <code>tokens_alloc_size</code> variable, which expands if the 	newly generated code from <code>struct</code> exceeds the original allocated	size. If your language doesn't have a command that dynamically generates code,	don't worry about implementing <code>tokens_alloc_size</code> or reallocating the	dynamic memory in <code>add_token_V()</code>. If you're interested in how	<code>handle_struct()</code> is created, it can be found in the GitHub source: 	<a href="https://github.com/fg123/wendy/blob/master/src/scanner.c#L65">scanner.c</a>.</p> <p>	With that, we are done the scanner module! Given a string of characters passed	into <code>scan_tokens()</code>, we should be able to get a string of tokens.	To see this in action, lets write a quick <code>print_token_list()</code> function	that allows us to visualize the list of tokens created.</p><pre><code class="cpp">void print_token_list(token* tokens, size_t size) {	for(int i = 0; i < size; i++) {		if(tokens[i].t_type == NUMBER) {			printf("{ %d -> %f }\n", tokens[i].t_type, tokens[i].t_data.number);		}		else {			printf("{ %d -> %s }\n", tokens[i].t_type, tokens[i].t_data.string);		}	}}</code></pre> <p>For this, the token_type enum will be printed as an index, so to verify, you	would have to go through manually and double check the index in the enum. 	We can now modify our <code>run()</code> function in <code>interpreter.c</code>	to check our scanner.</p><pre><code class="cpp">void run(char* input_string) {	tokens_count = scan_tokens(input_string, &tokens);	print_token_list(tokens, tokens_count);	//bool b;	//eval_fn(0, 0, 0, 0, &b);	free(tokens);}</code></pre><p>	After compiling, we can run the interpreter without any arguments and	we should reach REPL mode.</p><pre><code class="nohighlight nostyle">Welcome to Wendy 1.1Created by: Felix Guo> </code></pre><p>	If I type "let x = 10;" into the prompt and press enter, I should be greeted	with a list of tokens!</p><pre><code class="nohighlight nostyle">Welcome to Wendy 1.1Created by: Felix Guo> let x = 10;{ 37 -> let }{ 27 -> x }{ 21 -> = }{ 29 -> 10.000000 }{ 10 -> ; }> </code></pre><p>	We can double check the integers and verify that 37 refers to LET, 27 refers to 	IDENTIFIER, 21 refers to EQUAL, 29 to NUMBER, and 10 to SEMICOLON.</p><p>	In the next chapter, we explore how to evaluate basic mathematical expressions	in our interpreter, turning a string like: "((1 + 2) * 10) / (18 + 2)" into	1.5.</p>
				</div>

				<div class="col-md-3 col-md-pull-9 navigation">
					<div class="list-group mainmenu">
					</div>
				</div>
			</div>
		</div>
		<div class="fewter">
				&copy; Copyright Felix Guo 2017
		</div>		
		<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
		<!-- Include all compiled plugins (below), or include individual files as needed -->
		<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>		
		<script src="js/spy.js" type="text/javascript"></script>
		<script src="js/pageScroll.js" type="text/javascript"></script>
		<script src="../wendy/wendyHighlighting.js" type="text/javascript"></script>
		<script>
		$(document).ready(function() {
			$('pre code.cpp').each(function(i, block) {
				hljs.highlightBlock(block);
			});
		});
		</script>
		<!--<script src="js/rainbow-custom.min.js" type="text/javascript"></script>-->
	</body>
</html>
